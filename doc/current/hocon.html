<!DOCTYPE html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <title>HOCON (Human-Optimized Config Object Notation)</title> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <meta name="description" content="Werval Documentation"> 
  <meta name="keywords" content="werval, documentation"> 
  <!-- Le styles --> 
  <!-- See https://github.com/nerk/asciidoctor-bs-themes --> 
  <link href="css/bootstrap_lumen.css" rel="stylesheet"> 
  <link href="css/base.css" rel="stylesheet"> 
  <link href="css/io.werval.doc.css" rel="stylesheet"> 
  <link href="css/prettify.css" rel="stylesheet"> 
  <!-- HTML5 shim, for IE6-8 support of HTML5 elements --> 
  <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->  
  <!-- Async Analytics --> 
  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-57721420-1', 'auto');
        ga('send', 'pageview');
    </script> 
 </head> 
 <body onload="prettyPrint()" class="article toc2 toc-right"> 
  <div id="wrap"> 
   <!-- Fixed navbar --> 
   <div class="navbar navbar-default navbar-fixed-top" role="navigation"> 
    <div class="container"> 
     <div class="navbar-header"> 
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> 
      <a class="navbar-brand" href="index.html">Werval 0.7.2</a> 
     </div> 
     <div class="navbar-collapse collapse"> 
      <ul class="nav navbar-nav"> 
       <li class="dropdown"> <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting started <b class="caret"></b></a> 
        <ul class="dropdown-menu"> 
         <li><a href="get-started-gradle.html">Get started using Gradle</a></li> 
         <li><a href="get-started-maven.html">Get started using Maven</a></li> 
         <li class="divider"></li> 
         <li><a href="getting-started.html">What are Gradle &amp; Maven?</a></li> 
        </ul> </li> 
       <li><a href="guides.html">Guides</a></li> 
       <li><a href="manual.html">Manual</a></li> 
       <li><a href="modules/index.html">Modules</a></li> 
       <li><a href="api/index.html" target="_blank">API Javadoc</a></li> 
      </ul> 
      <ul class="nav navbar-nav navbar-right"> 
       <li class="dropdown"> <a href="#" class="dropdown-toggle" data-toggle="dropdown">Current Version (0.7.2)<span class="caret"></span></a> 
        <ul class="dropdown-menu" role="menu"> 
         <li><a href="/doc/current/index.html">Current Version (0.7.2)</a></li> 
         <li><a href="/doc/0.6.0/index.html">0.6.0</a></li> 
         <li><a href="/doc/0.5.1/index.html">0.5.1</a></li> 
         <li class="divider"></li> 
         <li><a href="/doc/develop/index.html">Development Version</a></li> 
         <li class="divider"></li> 
         <li><a href="/">Werval Home</a></li> 
        </ul> </li> 
      </ul> 
     </div> 
     <!--/.nav-collapse --> 
    </div> 
   </div> 
   <div class="container"> 
    <ol class="breadcrumb"> 
     <li><a href="index.html">Documentation</a></li> 
     <li class="active">HOCON (Human-Optimized Config Object Notation)</li> 
    </ol> 
    <div class="page-header"> 
     <h1>HOCON (Human-Optimized Config Object Notation)</h1> 
    </div> 
    <p></p> 
    <div id="preamble"> 
     <div class="sectionbody"> 
      <div class="paragraph"> 
       <p>This file was generated from the original <a href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON</a> specification published by TypeSafe under the Apache License 2.0.</p> 
      </div> 
      <div id="toc" class="toc2"> 
       <div id="toctitle" class="title">
         HOCON 
       </div> 
       <ul class="sectlevel1"> 
        <li><a href="#goals-background">Goals / Background</a></li> 
        <li><a href="#definitions">Definitions</a></li> 
        <li><a href="#syntax">Syntax</a></li> 
        <li> 
         <ul class="sectlevel2"> 
          <li><a href="#unchanged-from-json">Unchanged from JSON</a></li> 
          <li><a href="#comments">Comments</a></li> 
          <li><a href="#omit-root-braces">Omit root braces</a></li> 
          <li><a href="#key-value-separator">Key-value separator</a></li> 
          <li><a href="#commas">Commas</a></li> 
          <li><a href="#whitespace">Whitespace</a></li> 
          <li><a href="#duplicate-keys-and-object-merging">Duplicate keys and object merging</a></li> 
          <li><a href="#unquoted-strings">Unquoted strings</a></li> 
          <li><a href="#multi-line-strings">Multi-line strings</a></li> 
          <li><a href="#value-concatenation">Value concatenation</a></li> 
          <li><a href="#path-expressions">Path expressions</a></li> 
          <li><a href="#paths-as-keys">Paths as keys</a></li> 
          <li><a href="#substitutions">Substitutions</a></li> 
          <li><a href="#includes">Includes</a></li> 
          <li><a href="#conversion-of-numerically-indexed-objects-to-arrays">Conversion of numerically-indexed objects to arrays</a></li> 
         </ul> </li> 
        <li><a href="#mime-type">MIME Type</a></li> 
        <li><a href="#api-recommendations">API Recommendations</a></li> 
        <li> 
         <ul class="sectlevel2"> 
          <li><a href="#automatic-type-conversions">Automatic type conversions</a></li> 
          <li><a href="#units-format">Units format</a></li> 
          <li><a href="#duration-format">Duration format</a></li> 
          <li><a href="#size-in-bytes-format">Size in bytes format</a></li> 
          <li><a href="#config-object-merging-and-file-merging">Config object merging and file merging</a></li> 
          <li><a href="#java-properties-mapping">Java properties mapping</a></li> 
          <li><a href="#conventional-configuration-files-for-jvm-apps">Conventional configuration files for JVM apps</a></li> 
          <li><a href="#conventional-override-by-system-properties">Conventional override by system properties</a></li> 
          <li><a href="#substitution-fallback-to-environment-variables">Substitution fallback to environment variables</a></li> 
          <li><a href="#hyphen-separated-vs.-camelcase">hyphen-separated vs. camelCase</a></li> 
         </ul> </li> 
        <li><a href="#note-on-java-properties-similarity">Note on Java properties similarity</a></li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>This is an informal spec, but hopefully it’s clear.</p> 
      </div> 
     </div> 
    </div> 
    <div class="sect1"> 
     <h2 id="goals-background"><a class="anchor" href="#goals-background"></a>Goals / Background</h2> 
     <div class="sectionbody"> 
      <div class="paragraph"> 
       <p>The primary goal is: keep the semantics (tree structure; set of types; encoding/escaping) from JSON, but make it more convenient as a human-editable config file format.</p> 
      </div> 
      <div class="paragraph"> 
       <p>The following features are desirable, to support human usage:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>less noisy / less pedantic syntax</p> </li> 
        <li> <p>ability to refer to another part of the configuration (set a value to another value)</p> </li> 
        <li> <p>import/include another configuration file into the current file</p> </li> 
        <li> <p>a mapping to a flat properties list such as Java’s system properties</p> </li> 
        <li> <p>ability to get values from environment variables</p> </li> 
        <li> <p>ability to write comments</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>Implementation-wise, the format should have these properties:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>a JSON superset, that is, all valid JSON should be valid and should result in the same in-memory data that a JSON parser would have produced.</p> </li> 
        <li> <p>be deterministic; the format is flexible, but it is not heuristic. It should be clear what’s invalid and invalid files should generate errors.</p> </li> 
        <li> <p>require minimal look-ahead; should be able to tokenize the file by looking at only the next three characters. (right now, the only reason to look at three is to find "//" comments; otherwise you can parse looking at two.)</p> </li> 
       </ul> 
      </div> 
      <div class="paragraph"> 
       <p>HOCON is significantly harder to specify and to parse than JSON. Think of it as moving the work from the person maintaining the config file to the computer program.</p> 
      </div> 
     </div> 
    </div> 
    <div class="sect1"> 
     <h2 id="definitions"><a class="anchor" href="#definitions"></a>Definitions</h2> 
     <div class="sectionbody"> 
      <div class="ulist"> 
       <ul> 
        <li> <p>a <em>key</em> is a string JSON would have to the left of <code>:</code> and a <em>value</em> is anything JSON would have to the right of <code>:</code>. i.e. the two halves of an object <em>field</em>.</p> </li> 
        <li> <p>a <em>value</em> is any "value" as defined in the JSON spec, plus unquoted strings and substitutions as defined in this spec.</p> </li> 
        <li> <p>a <em>simple value</em> is any value excluding an object or array value.</p> </li> 
        <li> <p>a <em>field</em> is a key, any separator such as <em>:</em>, and a value.</p> </li> 
        <li> <p>references to a <em>file</em> ("the file being parsed") can be understood to mean any byte stream being parsed, not just literal files in a filesystem.</p> </li> 
       </ul> 
      </div> 
     </div> 
    </div> 
    <div class="sect1"> 
     <h2 id="syntax"><a class="anchor" href="#syntax"></a>Syntax</h2> 
     <div class="sectionbody"> 
      <div class="paragraph"> 
       <p>Much of this is defined with reference to JSON; you can find the JSON spec at <a href="http://json.org/">http://json.org/</a> of course.</p> 
      </div> 
      <div class="sect2"> 
       <h3 id="unchanged-from-json"><a class="anchor" href="#unchanged-from-json"></a>Unchanged from JSON</h3> 
       <div class="ulist"> 
        <ul> 
         <li> <p>files must be valid UTF-8</p> </li> 
         <li> <p>quoted strings are in the same format as JSON strings</p> </li> 
         <li> <p>values have possible types: string, number, object, array, boolean, null</p> </li> 
         <li> <p>allowed number formats matches JSON; as in JSON, some possible floating-point values are not represented, such as <code>NaN</code></p> </li> 
        </ul> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="comments"><a class="anchor" href="#comments"></a>Comments</h3> 
       <div class="paragraph"> 
        <p>Anything between <code>//</code> or <code>#</code> and the next newline is considered a comment and ignored, unless the <code>//</code> or <code>#</code> is inside a quoted string.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="omit-root-braces"><a class="anchor" href="#omit-root-braces"></a>Omit root braces</h3> 
       <div class="paragraph"> 
        <p>JSON documents must have an array or object at the root. Empty files are invalid documents, as are files containing only a non-array non-object value such as a string.</p> 
       </div> 
       <div class="paragraph"> 
        <p>In HOCON, if the file does not begin with a square bracket or curly brace, it is parsed as if it were enclosed with <code>{}</code> curly braces.</p> 
       </div> 
       <div class="paragraph"> 
        <p>A HOCON file is invalid if it omits the opening <code>{</code> but still has a closing <code>}</code>; the curly braces must be balanced.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="key-value-separator"><a class="anchor" href="#key-value-separator"></a>Key-value separator</h3> 
       <div class="paragraph"> 
        <p>The <code>=</code> character can be used anywhere JSON allows <code>:</code>, i.e. to separate keys from values.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If a key is followed by <code>{</code>, the <code>:</code> or <code>=</code> may be omitted. So <code>"foo" {}</code> means <code>"foo" : {}</code></p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="commas"><a class="anchor" href="#commas"></a>Commas</h3> 
       <div class="paragraph"> 
        <p>Values in arrays, and fields in objects, need not have a comma between them as long as they have at least one ASCII newline (<code>\n</code>, decimal value 10) between them.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The last element in an array or last field in an object may be followed by a single comma. This extra comma is ignored.</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>[1,2,3,]</code> and <code>[1,2,3]</code> are the same array.</p> </li> 
         <li> <p><code>[1\n2\n3]</code> and <code>[1,2,3]</code> are the same array.</p> </li> 
         <li> <p><code>[1,2,3,,]</code> is invalid because it has two trailing commas.</p> </li> 
         <li> <p><code>[,1,2,3]</code> is invalid because it has an initial comma.</p> </li> 
         <li> <p><code>[1,,2,3]</code> is invalid because it has two commas in a row.</p> </li> 
         <li> <p>these same comma rules apply to fields in objects.</p> </li> 
        </ul> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="whitespace"><a class="anchor" href="#whitespace"></a>Whitespace</h3> 
       <div class="paragraph"> 
        <p>The JSON spec simply says "whitespace"; in HOCON whitespace is defined as follows:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>any Unicode space separator (Zs category), line separator (Zl category), or paragraph separator (Zp category), including nonbreaking spaces (such as 0x00A0, 0x2007, and 0x202F). The BOM (0xFEFF) must also be treated as whitespace.</p> </li> 
         <li> <p>tab (<code>\t</code> 0x0009), newline (<em>' 0x000A), vertical tab (</em>' 0x000B)<code>, form feed (</code>' 0x000C), carriage return ('' 0x000D), file separator (0x001C), group separator (0x001D), record separator (0x001E), unit separator (0x001F).</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>In Java, the <code>isWhitespace()</code> method covers these characters with the exception of nonbreaking spaces and the BOM.</p> 
       </div> 
       <div class="paragraph"> 
        <p>While all Unicode separators should be treated as whitespace, in this spec "newline" refers only and specifically to ASCII newline 0x000A.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="duplicate-keys-and-object-merging"><a class="anchor" href="#duplicate-keys-and-object-merging"></a>Duplicate keys and object merging</h3> 
       <div class="paragraph"> 
        <p>The JSON spec does not clarify how duplicate keys in the same object should be handled. In HOCON, duplicate keys that appear later override those that appear earlier, unless both values are objects. If both values are objects, then the objects are merged.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Note: this would make HOCON a non-superset of JSON if you assume that JSON requires duplicate keys to have a behavior. The assumption here is that duplicate keys are invalid JSON.</p> 
       </div> 
       <div class="paragraph"> 
        <p>To merge objects:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>add fields present in only one of the two objects to the merged object.</p> </li> 
         <li> <p>for non-object-valued fields present in both objects, the field found in the second object must be used.</p> </li> 
         <li> <p>for object-valued fields present in both objects, the object values should be recursively merged according to these same rules.</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Object merge can be prevented by setting the key to another value first. This is because merging is always done two values at a time; if you set a key to an object, a non-object, then an object, first the non-object falls back to the object (non-object always wins), and then the object falls back to the non-object (no merging, object is the new value). So the two objects never see each other.</p> 
       </div> 
       <div class="paragraph"> 
        <p>These two are equivalent:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>{
    "foo" : { "a" : 42 },
    "foo" : { "b" : 43 }
}

{
    "foo" : { "a" : 42, "b" : 43 }
}</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>And these two are equivalent:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>{
    "foo" : { "a" : 42 },
    "foo" : null,
    "foo" : { "b" : 43 }
}

{
    "foo" : { "b" : 43 }
}</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>The intermediate setting of <code>"foo"</code> to <code>null</code> prevents the object merge.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="unquoted-strings"><a class="anchor" href="#unquoted-strings"></a>Unquoted strings</h3> 
       <div class="paragraph"> 
        <p>A sequence of characters outside of a quoted string is a string value if:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>it does not contain "forbidden characters": <em>$</em>, <em>"</em>, <em>\{</em>, <em>}</em>, <em>[</em>, <em>]</em>, <em>:</em>, <em>=</em>, <em>,</em>, <em>+</em>, <em>#</em>, <em>‘</em>, <em>^</em>, <em>?</em>, <em>!</em>, <em>@</em>, <em>*</em>, <em>&amp;</em>, '’ (backslash), or whitespace.</p> </li> 
         <li> <p>it does not contain the two-character string "//" (which starts a comment)</p> </li> 
         <li> <p>its initial characters do not parse as <code>true</code>, <code>false</code>, <code>null</code>, or a number.</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Unquoted strings are used literally, they do not support any kind of escaping. Quoted strings may always be used as an alternative when you need to write a character that is not permitted in an unquoted string.</p> 
       </div> 
       <div class="paragraph"> 
        <p><code>truefoo</code> parses as the boolean token <code>true</code> followed by the unquoted string <code>foo</code>. However, <code>footrue</code> parses as the unquoted string <code>footrue</code>. Similarly, <code>10.0bar</code> is the number <code>10.0</code> then the unquoted string <code>bar</code> but <code>bar10.0</code> is the unquoted string <code>bar10.0</code>. (In practice, this distinction doesn’t matter much because of value concatenation; see later section.)</p> 
       </div> 
       <div class="paragraph"> 
        <p>In general, once an unquoted string begins, it continues until a forbidden character or the two-character string "//" is encountered. Embedded (non-initial) booleans, nulls, and numbers are not recognized as such, they are part of the string.</p> 
       </div> 
       <div class="paragraph"> 
        <p>An unquoted string may not <em>begin</em> with the digits 0-9 or with a hyphen (<code>-</code>, 0x002D) because those are valid characters to begin a JSON number. The initial number character, plus any valid-in-JSON number characters that follow it, must be parsed as a number value. Again, these characters are not special <em>inside</em> an unquoted string; they only trigger number parsing if they appear initially.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Note that quoted JSON strings may not contain control characters (control characters include some whitespace characters, such as newline). This rule is from the JSON spec. However, unquoted strings have no restriction on control characters, other than the ones listed as "forbidden characters" above.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Some of the "forbidden characters" are forbidden because they already have meaning in JSON or HOCON, others are essentially reserved keywords to allow future extensions to this spec.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="multi-line-strings"><a class="anchor" href="#multi-line-strings"></a>Multi-line strings</h3> 
       <div class="paragraph"> 
        <p>Multi-line strings are similar to Python or Scala, using triple quotes. If the three-character sequence <code>"""</code> appears, then all Unicode characters until a closing <code>"""</code> sequence are used unmodified to create a string value. Newlines and whitespace receive no special treatment. Unlike Scala, and unlike JSON quoted strings, Unicode escapes are not interpreted in triple-quoted strings.</p> 
       </div> 
       <div class="paragraph"> 
        <p>In Python, <code>"""foo""""</code> is a syntax error (a triple-quoted string followed by a dangling unbalanced quote). In Scala, it is a four-character string <code>foo"</code>. HOCON works like Scala; any sequence of at least three quotes ends the multi-line string, and any "extra" quotes are part of the string.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="value-concatenation"><a class="anchor" href="#value-concatenation"></a>Value concatenation</h3> 
       <div class="paragraph"> 
        <p>The value of an object field or array element may consist of multiple values which are combined. There are three kinds of value concatenation:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>if all the values are simple values (neither objects nor arrays), they are concatenated into a string.</p> </li> 
         <li> <p>if all the values are arrays, they are concatenated into one array.</p> </li> 
         <li> <p>if all the values are objects, they are merged (as with duplicate keys) into one object.</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>String value concatenation is allowed in field keys, in addition to field values and array elements. Objects and arrays do not make sense as field keys.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Note: Akka 2.0 (and thus Play 2.0) contains an embedded implementation of the config lib which does not support array and object value concatenation; it only supports string value concatenation.</p> 
       </div> 
       <div class="sect3"> 
        <h4 id="string-value-concatenation"><a class="anchor" href="#string-value-concatenation"></a>String value concatenation</h4> 
        <div class="paragraph"> 
         <p>String value concatenation is the trick that makes unquoted strings work; it also supports substitutions (<code>${foo}</code> syntax) in strings.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Only simple values participate in string value concatenation. Recall that a simple value is any value other than arrays and objects.</p> 
        </div> 
        <div class="paragraph"> 
         <p>As long as simple values are separated only by non-newline whitespace, the <em>whitespace between them is preserved</em> and the values, along with the whitespace, are concatenated into a string.</p> 
        </div> 
        <div class="paragraph"> 
         <p>String value concatenations never span a newline, or a character that is not part of a simple value.</p> 
        </div> 
        <div class="paragraph"> 
         <p>A string value concatenation may appear in any place that a string may appear, including object keys, object values, and array elements.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Whenever a value would appear in JSON, a HOCON parser instead collects multiple values (including the whitespace between them) and concatenates those values into a string.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Whitespace before the first and after the last simple value must be discarded. Only whitespace <em>between</em> simple values must be preserved.</p> 
        </div> 
        <div class="paragraph"> 
         <p>So for example <code>foo bar baz</code> parses as three unquoted strings, and the three are value-concatenated into one string. The inner whitespace is kept and the leading and trailing whitespace is trimmed. The equivalent string, written in quoted form, would be <code>"foo bar baz"</code>.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Value concatenating <code>foo bar</code> (two unquoted strings with whitespace) and quoted string <code>"foo bar"</code> would result in the same in-memory representation, seven characters.</p> 
        </div> 
        <div class="paragraph"> 
         <p>For purposes of string value concatenation, non-string values are converted to strings as follows (strings shown as quoted strings):</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p><code>true</code> and <code>false</code> become the strings <code>"true"</code> and <code>"false"</code>.</p> </li> 
          <li> <p><code>null</code> becomes the string <code>"null"</code>.</p> </li> 
          <li> <p>quoted and unquoted strings are themselves.</p> </li> 
          <li> <p>numbers should be kept as they were originally written in the file. For example, if you parse <code>1e5</code> then you might render it alternatively as <code>1E5</code> with capital <code>E</code>, or just <code>100000</code>. For purposes of value concatenation, it should be rendered as it was written in the file.</p> </li> 
          <li> <p>a substitution is replaced with its value which is then converted to a string as above.</p> </li> 
          <li> <p>it is invalid for arrays or objects to appear in a string value concatenation.</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>A single value is never converted to a string. That is, it would be wrong to value concatenate <code>true</code> by itself; that should be parsed as a boolean-typed value. Only <code>true foo</code> (<code>true</code> with another simple value on the same line) should be parsed as a value concatenation and converted to a string.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="array-and-object-concatenation"><a class="anchor" href="#array-and-object-concatenation"></a>Array and object concatenation</h4> 
        <div class="paragraph"> 
         <p>Arrays can be concatenated with arrays, and objects with objects, but it is an error if they are mixed.</p> 
        </div> 
        <div class="paragraph"> 
         <p>For purposes of concatenation, "array" also means "substitution that resolves to an array" and "object" also means "substitution that resolves to an object."</p> 
        </div> 
        <div class="paragraph"> 
         <p>Within an field value or array element, if only non-newline whitespace separates the end of a first array or object or substitution from the start of a second array or object or substitution, the two values are concatenated. Newlines may occur <em>within</em> the array or object, but not <em>between</em> them. Newlines <em>between</em> prevent concatenation.</p> 
        </div> 
        <div class="paragraph"> 
         <p>For objects, "concatenation" means "merging", so the second object overrides the first.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Arrays and objects cannot be field keys, whether concatenation is involved or not.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Here are several ways to define <code>a</code> to the same object value:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>// one object
a : { b : 1, c : 2 }
// two objects that are merged via concatenation rules
a : { b : 1 } { c : 2 }
// two fields that are merged
a : { b : 1 }
a : { c : 2 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Here are several ways to define <code>a</code> to the same array value:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>// one array
a : [ 1, 2, 3, 4 ]
// two arrays that are concatenated
a : [ 1, 2 ] [ 3, 4 ]
// a later definition referring to an earlier
// (see "self-referential substitutions" below)
a : [ 1, 2 ]
a : ${a} [ 3, 4 ]</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>A common use of object concatenation is "inheritance":</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>data-center-generic = { cluster-size = 6 }
data-center-east = ${data-center-generic} { name = "east" }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>A common use of array concatenation is to add to paths:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>path = [ /bin ]
path = ${path} [ /usr/bin ]</pre> 
         </div> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="note-arrays-without-commas-or-newlines"><a class="anchor" href="#note-arrays-without-commas-or-newlines"></a>Note: Arrays without commas or newlines</h4> 
        <div class="paragraph"> 
         <p>Arrays allow you to use newlines instead of commas, but not whitespace instead of commas. Non-newline whitespace will produce concatenation rather than separate elements.</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>// this is an array with one element, the string "1 2 3 4"
[ 1 2 3 4 ]
// this is an array of four integers
[ 1
  2
  3
  4 ]

// an array of one element, the array [ 1, 2, 3, 4 ]
[ [ 1, 2 ] [ 3, 4 ] ]
// an array of two arrays
[ [ 1, 2 ]
  [ 3, 4 ] ]</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>If this gets confusing, just use commas. The concatenation behavior is useful rather than surprising in cases like:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>[ This is an unquoted string my name is ${name}, Hello ${world} ]
[ ${a} ${b}, ${x} ${y} ]</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Non-newline whitespace is never an element or field separator.</p> 
        </div> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="path-expressions"><a class="anchor" href="#path-expressions"></a>Path expressions</h3> 
       <div class="paragraph"> 
        <p>Path expressions are used to write out a path through the object graph. They appear in two places; in substitutions, like <code>${foo.bar}</code>, and as the keys in objects like <code>{ foo.bar : 42 }</code>.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Path expressions are syntactically identical to a value concatenation, except that they may not contain substitutions. This means that you can’t nest substitutions inside other substitutions, and you can’t have substitutions in keys.</p> 
       </div> 
       <div class="paragraph"> 
        <p>When concatenating the path expression, any <code>.</code> characters outside quoted strings are understood as path separators, while inside quoted strings <code>.</code> has no special meaning. So <code>foo.bar."hello.world"</code> would be a path with three elements, looking up key <code>foo</code>, key <code>bar</code>, then key <code>hello.world</code>.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The main tricky point is that <code>.</code> characters in numbers do count as a path separator. When dealing with a number as part of a path expression, it’s essential to retain the <em>original</em> string representation of the number as it appeared in the file (rather than converting it back to a string with a generic number-to-string library function).</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>10.0foo</code> is a number then unquoted string <code>foo</code> and should be the two-element path with <code>10</code> and <code>0foo</code> as the elements.</p> </li> 
         <li> <p><code>foo10.0</code> is an unquoted string with a <code>.</code> in it, so this would be a two-element path with <code>foo10</code> and <code>0</code> as the elements.</p> </li> 
         <li> <p><code>foo"10.0"</code> is an unquoted then a quoted string which are concatenated, so this is a single-element path.</p> </li> 
         <li> <p><code>1.2.3</code> is the three-element path with <code>1</code>,<code>2</code>,<code>3</code></p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Unlike value concatenations, path expressions are <em>always</em> converted to a string, even if they are just a single value.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If you have an array or element value consisting of the single value <code>true</code>, it’s a value concatenation and retains its character as a boolean value.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If you have a path expression (in a key or substitution) then it must always be converted to a string, so <code>true</code> becomes the string that would be quoted as <code>"true"</code>.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If a path element is an empty string, it must always be quoted. That is, <code>a."".b</code> is a valid path with three elements, and the middle element is an empty string. But <code>a..b</code> is invalid and should generate an error. Following the same rule, a path that starts or ends with a <code>.</code> is invalid and should generate an error.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="paths-as-keys"><a class="anchor" href="#paths-as-keys"></a>Paths as keys</h3> 
       <div class="paragraph"> 
        <p>If a key is a path expression with multiple elements, it is expanded to create an object for each path element other than the last. The last path element, combined with the value, becomes a field in the most-nested object.</p> 
       </div> 
       <div class="paragraph"> 
        <p>In other words:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>foo.bar : 42</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>is equivalent to:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>foo { bar : 42 }</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>and:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>foo.bar.baz : 42</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>is equivalent to:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>foo { bar { baz : 42 } }</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>and so on. These values are merged in the usual way; which implies that:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>a.x : 42, a.y : 43</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>is equivalent to:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>a { x : 42, y : 43 }</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>Because path expressions work like value concatenations, you can have whitespace in keys:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>a b c : 42</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>is equivalent to:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>"a b c" : 42</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>Because path expressions are always converted to strings, even single values that would normally have another type become strings.</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>true : 42</code> is <code>"true" : 42</code></p> </li> 
         <li> <p><code>3 : 42</code> is <code>"3" : 42</code></p> </li> 
         <li> <p><code>3.14 : 42</code> is <code>"3" : { "14" : 42 }</code></p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>As a special rule, the unquoted string <code>include</code> may not begin a path expression in a key, because it has a special interpretation (see below).</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="substitutions"><a class="anchor" href="#substitutions"></a>Substitutions</h3> 
       <div class="paragraph"> 
        <p>Substitutions are a way of referring to other parts of the configuration tree.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The syntax is <code>${pathexpression}</code> or <code>${?pathexpression}</code> where the <code>pathexpression</code> is a path expression as described above. This path expression has the same syntax that you could use for an object key.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The <code>?</code> in <code>${?pathexpression}</code> must not have whitespace before it; the three characters <code>${?</code> must be exactly like that, grouped together.</p> 
       </div> 
       <div class="paragraph"> 
        <p>For substitutions which are not found in the configuration tree, implementations may try to resolve them by looking at system environment variables or other external sources of configuration. (More detail on environment variables in a later section.)</p> 
       </div> 
       <div class="paragraph"> 
        <p>Substitutions are not parsed inside quoted strings. To get a string containing a substitution, you must use value concatenation with the substitution in the unquoted portion:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>key : ${animal.favorite} is my favorite animal</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>Or you could quote the non-substitution portion:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>key : ${animal.favorite}" is my favorite animal"</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>Substitutions are resolved by looking up the path in the configuration. The path begins with the root configuration object, i.e. it is "absolute" rather than "relative."</p> 
       </div> 
       <div class="paragraph"> 
        <p>Substitution processing is performed as the last parsing step, so a substitution can look forward in the configuration. If a configuration consists of multiple files, it may even end up retrieving a value from another file.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If a key has been specified more than once, the substitution will always evaluate to its latest-assigned value (that is, it will evaluate to the merged object, or the last non-object value that was set, in the entire document being parsed including all included files).</p> 
       </div> 
       <div class="paragraph"> 
        <p>If a configuration sets a value to <code>null</code> then it should not be looked up in the external source. Unfortunately there is no way to "undo" this in a later configuration file; if you have <code>{ "HOME" : null }</code> in a root object, then <code>${HOME}</code> will never look at the environment variable. There is no equivalent to JavaScript’s <code>delete</code> operation in other words.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If a substitution does not match any value present in the configuration and is not resolved by an external source, then it is undefined. An undefined substitution with the <code>${foo}</code> syntax is invalid and should generate an error.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If a substitution with the <code>${?foo}</code> syntax is undefined:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>if it is the value of an object field then the field should not be created. If the field would have overridden a previously-set value for the same field, then the previous value remains.</p> </li> 
         <li> <p>if it is an array element then the element should not be added.</p> </li> 
         <li> <p>if it is part of a value concatenation with another string then it should become an empty string; if part of a value concatenation with an object or array it should become an empty object or array.</p> </li> 
         <li> <p><code>foo : ${?bar}</code> would avoid creating field <code>foo</code> if <code>bar</code> is undefined. <code>foo : ${?bar}${?baz}</code> would also avoid creating the field if <em>both</em> <code>bar</code> and <code>baz</code> are undefined.</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Substitutions are only allowed in field values and array elements (value concatenations), they are not allowed in keys or nested inside other substitutions (path expressions).</p> 
       </div> 
       <div class="paragraph"> 
        <p>A substitution is replaced with any value type (number, object, string, array, true, false, null). If the substitution is the only part of a value, then the type is preserved. Otherwise, it is value-concatenated to form a string.</p> 
       </div> 
       <div class="sect3"> 
        <h4 id="self-referential-substitutions"><a class="anchor" href="#self-referential-substitutions"></a>Self-Referential Substitutions</h4> 
        <div class="paragraph"> 
         <p>The big picture:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>substitutions normally "look forward" and use the final value for their path expression</p> </li> 
          <li> <p>when this would create a cycle, when possible the cycle must be broken by looking backward only (thus removing one of the substitutions that’s a link in the cycle)</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>The idea is to allow a new value for a field to be based on the older value:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>path : "a:b:c"
path : ${path}":d"</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>A <em>self-referential field</em> is one which:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>has a substitution, or value concatenation containing a substitution, as its value</p> </li> 
          <li> <p>where this field value refers to the field being defined, either directly or by referring to one or more other substitutions which eventually point back to the field being defined</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>Examples of self-referential fields:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p><code>a : ${a}</code></p> </li> 
          <li> <p><code>a : ${a}bc</code></p> </li> 
          <li> <p><code>path : ${path} [ /usr/bin ]</code></p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>Note that an object or array with a substitution inside it is <em>not</em> considered self-referential for this purpose. The self-referential rules do <em>not</em> apply to:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p><code>a : { b : ${a} }</code></p> </li> 
          <li> <p><code>a : [${a}]</code></p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>These cases are unbreakable cycles that generate an error. (If "looking backward" were allowed for these, something like <code>a={ x : 42, y : ${a.x} }</code> would look backward for a nonexistent <code>a</code> while resolving <code>${a.x}</code>.)</p> 
        </div> 
        <div class="paragraph"> 
         <p>A possible implementation is:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>substitutions are resolved by looking up paths in a document. Cycles only arise when the lookup document is an ancestor node of the substitution node.</p> </li> 
          <li> <p>while resolving a potentially self-referential field (any substitution or value concatenation that contains a substitution), remove that field and all fields which override it from the lookup document.</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>The simplest form of this implementation will report a circular reference as missing; in <code>a : ${a}</code> you would remove <code>a : ${a}</code> while resolving <code>${a}</code>, leaving an empty document to look up <code>${a}</code> in. You can give a more helpful error message if, rather than simply removing the field, you leave a marker value describing the cycle. Then generate an error if you return to that marker value during resolution.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Cycles should be treated the same as a missing value when resolving an optional substitution (i.e. the <code>${?foo}</code> syntax). If <code>${?foo}</code> refers to itself then it’s as if it referred to a nonexistent value.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="the-field-separator"><a class="anchor" href="#the-field-separator"></a>The <code>+=</code> field separator</h4> 
        <div class="paragraph"> 
         <p>Fields may have <code>+=</code> as a separator rather than <code>:</code> or <code>=</code>. A field with <code>+=</code> transforms into a self-referential array concatenation, like this:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>a += b</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>becomes:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>a = ${?a} [b]</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p><code>+=</code> appends an element to a previous array. If the previous value was not an array, an error will result just as it would in the long form <code>a = ${?a} [b]</code>. Note that the previous value is optional (<code>${?a}</code> not <code>${a}</code>), which allows <code>a += b</code> to be the first mention of <code>a</code> in the file (it is not necessary to have <code>a = []</code> first).</p> 
        </div> 
        <div class="paragraph"> 
         <p>Note: Akka 2.0 (and thus Play 2.0) contains an embedded implementation of the config lib which does not support <code>+=</code>.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="examples-of-self-referential-substitutions"><a class="anchor" href="#examples-of-self-referential-substitutions"></a>Examples of Self-Referential Substitutions</h4> 
        <div class="paragraph"> 
         <p>In isolation (with no merges involved), a self-referential field is an error because the substitution cannot be resolved:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : ${foo} // an error</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>When <code>foo : ${foo}</code> is merged with an earlier value for <code>foo</code>, however, the substitution can be resolved to that earlier value. When merging two objects, the self-reference in the overriding field refers to the overridden field. Say you have:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : { a : 1 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>and then:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : ${foo}</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Then <code>${foo}</code> resolves to <code>{ a : 1 }</code>, the value of the overridden field.</p> 
        </div> 
        <div class="paragraph"> 
         <p>It would be an error if these two fields were reversed, so first:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : ${foo}</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>and then second:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : { a : 1 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Here the <code>${foo}</code> self-reference comes before <code>foo</code> has a value, so it is undefined, exactly as if the substitution referenced a path not found in the document.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Because <code>foo : ${foo}</code> conceptually looks to previous definitions of <code>foo</code> for a value, the error should be treated as "undefined" rather than "intractable cycle"; as a result, the optional substitution syntax <code>${?foo}</code> does not create a cycle:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : ${?foo} // this field just disappears silently</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>If a substitution is hidden by a value that could not be merged with it (by a non-object value) then it is never evaluated and no error will be reported. So for example:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : ${does-not-exist}
foo : 42</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>In this case, no matter what <code>${does-not-exist}</code> resolves to, we know <code>foo</code> is <code>42</code>, so <code>${does-not-exist}</code> is never evaluated and there is no error. The same is true for cycles like <code>foo : ${foo}, foo : 42</code>, where the initial self-reference must simply be ignored.</p> 
        </div> 
        <div class="paragraph"> 
         <p>A self-reference resolves to the value "below" even if it’s part of a path expression. So for example:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>foo : { a : { c : 1 } }
foo : ${foo.a}
foo : { a : 2 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Here, <code>${foo.a}</code> would refer to <code>{ c : 1 }</code> rather than <code>2</code> and so the final merge would be <code>{ a : 2, c : 1 }</code>.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Recall that for a field to be self-referential, it must have a substitution or value concatenation as its value. If a field has an object or array value, for example, then it is not self-referential even if there is a reference to the field itself inside that object or array.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Implementations must be careful to allow objects to refer to paths within themselves, for example:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>bar : { foo : 42,
        baz : ${bar.foo}
      }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Here, if an implementation resolved all substitutions in <code>bar</code> as part of resolving the substitution <code>${bar.foo}</code>, there would be a cycle. The implementation must only resolve the <code>foo</code> field in <code>bar</code>, rather than recursing the entire <code>bar</code> object.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Because there is no inherent cycle here, the substitution must "look forward" (including looking at the field currently being defined). To make this clearer, <code>bar.baz</code> would be <code>43</code> in:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>bar : { foo : 42,
        baz : ${bar.foo}
      }
bar : { foo : 43 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Mutually-referring objects should also work, and are not self-referential (so they look forward):</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>// bar.a should end up as 4
bar : { a : ${foo.d}, b : 1 }
bar.b = 3
// foo.c should end up as 3
foo : { c : ${bar.b}, d : 2 }
foo.d = 4</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Another tricky case is an optional self-reference in a value concatenation, in this example <code>a</code> should be <code>foo</code> not <code>foofoo</code> because the self reference has to "look back" to an undefined <code>a</code>:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>a = ${?a}foo</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>In general, in resolving a substitution the implementation must:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>lazy-evaluate the substitution target so there’s no "circularity by side effect"</p> </li> 
          <li> <p>"look forward" and use the final value for the path specified in the substitution</p> </li> 
          <li> <p>if a cycle results, the implementation must "look back" in the merge stack to try to resolve the cycle</p> </li> 
          <li> <p>if neither lazy evaluation nor "looking only backward" resolves a cycle, the substitution is missing which is an error unless the <code>${?foo}</code> optional-substitution syntax was used.</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>For example, this is not possible to resolve:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>bar : ${foo}
foo : ${bar}</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>A multi-step loop like this should also be detected as invalid:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>a : ${b}
b : ${c}
c : ${a}</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Some cases have undefined behavior because the behavior depends on the order in which two fields are resolved, and that order is not defined. For example:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>a : 1
b : 2
a : ${b}
b : ${a}</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Implementations are allowed to handle this by setting both <code>a</code> and <code>b</code> to 1, setting both to <code>2</code>, or generating an error. Ideally this situation would generate an error, but that may be difficult to implement. Making the behavior defined would require always working with ordered maps rather than unordered maps, which is too constraining. Implementations only have to track order for duplicate instances of the same field (i.e. merges).</p> 
        </div> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="includes"><a class="anchor" href="#includes"></a>Includes</h3> 
       <div class="sect3"> 
        <h4 id="include-syntax"><a class="anchor" href="#include-syntax"></a>Include syntax</h4> 
        <div class="paragraph"> 
         <p>An <em>include statement</em> consists of the unquoted string <code>include</code> followed by whitespace and then either: - a single <em>quoted</em> string which is interpreted heuristically as URL, filename, or classpath resource. - <code>url()</code>, <code>file()</code>, or <code>classpath()</code> surrounding a quoted string which is then interpreted as a URL, file, or classpath. The string must be quoted, unlike in CSS.</p> 
        </div> 
        <div class="paragraph"> 
         <p>An include statement can appear in place of an object field.</p> 
        </div> 
        <div class="paragraph"> 
         <p>If the unquoted string <code>include</code> appears at the start of a path expression where an object key would be expected, then it is not interpreted as a path expression or a key.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Instead, the next value must be a <em>quoted</em> string or a quoted string surrounded by <code>url()</code>, <code>file()</code>, or <code>classpath()</code>. This value is the <em>resource name</em>.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Together, the unquoted <code>include</code> and the resource name substitute for an object field syntactically, and are separated from the following object fields or includes by the usual comma (and as usual the comma may be omitted if there’s a newline).</p> 
        </div> 
        <div class="paragraph"> 
         <p>If an unquoted <code>include</code> at the start of a key is followed by anything other than a single quoted string or the <code>url("")</code>/<code>file("")</code>/<code>classpath("")</code> syntax, it is invalid and an error should be generated.</p> 
        </div> 
        <div class="paragraph"> 
         <p>There can be any amount of whitespace, including newlines, between the unquoted <code>include</code> and the resource name. For <code>url()</code> etc., whitespace is allowed inside the parentheses <code>()</code> (outside of the quotes).</p> 
        </div> 
        <div class="paragraph"> 
         <p>Value concatenation is NOT performed on the "argument" to <code>include</code> or <code>url()</code> etc. The argument must be a single quoted string. No substitutions are allowed, and the argument may not be an unquoted string or any other kind of value.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Unquoted <code>include</code> has no special meaning if it is not the start of a key’s path expression.</p> 
        </div> 
        <div class="paragraph"> 
         <p>It may appear later in the key:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre># this is valid
{ foo include : 42 }
# equivalent to
{ "foo include" : 42 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>It may appear as an object or array value:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>{ foo : include } # value is the string "include"
[ include ]       # array of one string "include"</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>You can quote <code>"include"</code> if you want a key that starts with the word <code>"include"</code>, only unquoted <code>include</code> is special:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>{ "include" : 42 }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Note: Akka 2.0 (and thus Play 2.0) contains an embedded implementation of the config lib which does not support the <code>url()</code>/<code>file()</code>/<code>classpath()</code> syntax. Only the heuristic <code>include "foo"</code> syntax is supported in that version.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="include-semantics-merging"><a class="anchor" href="#include-semantics-merging"></a>Include semantics: merging</h4> 
        <div class="paragraph"> 
         <p>An <em>including file</em> contains the include statement and an <em>included file</em> is the one specified in the include statement. (They need not be regular files on a filesystem, but assume they are for the moment.)</p> 
        </div> 
        <div class="paragraph"> 
         <p>An included file must contain an object, not an array. This is significant because both JSON and HOCON allow arrays as root values in a document.</p> 
        </div> 
        <div class="paragraph"> 
         <p>If an included file contains an array as the root value, it is invalid and an error should be generated.</p> 
        </div> 
        <div class="paragraph"> 
         <p>The included file should be parsed, producing a root object. The keys from the root object are conceptually substituted for the include statement in the including file.</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>If a key in the included object occurred prior to the include statement in the including object, the included key’s value overrides or merges with the earlier value, exactly as with duplicate keys found in a single file.</p> </li> 
          <li> <p>If the including file repeats a key from an earlier-included object, the including file’s value would override or merge with the one from the included file.</p> </li> 
         </ul> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="include-semantics-substitution"><a class="anchor" href="#include-semantics-substitution"></a>Include semantics: substitution</h4> 
        <div class="paragraph"> 
         <p>Substitutions in included files are looked up at two different paths; first, relative to the root of the included file; second, relative to the root of the including configuration.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Recall that substitution happens as a final step, <em>after</em> parsing. It should be done for the entire app’s configuration, not for single files in isolation.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Therefore, if an included file contains substitutions, they must be "fixed up" to be relative to the app’s configuration root.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Say for example that the root configuration is this:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>{ a : { include "foo.conf" } }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>And "foo.conf" might look like this:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>{ x : 10, y : ${x} }</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>If you parsed "foo.conf" in isolation, then <code>${x}</code> would evaluate to 10, the value at the path <code>x</code>. If you include "foo.conf" in an object at key <code>a</code>, however, then it must be fixed up to be <code>${a.x}</code> rather than <code>${x}</code>.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Say that the root configuration redefines <code>a.x</code>, like this:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>{
    a : { include "foo.conf" }
    a : { x : 42 }
}</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>Then the <code>${x}</code> in "foo.conf", which has been fixed up to <code>${a.x}</code>, would evaluate to <code>42</code> rather than to <code>10</code>. Substitution happens <em>after</em> parsing the whole configuration.</p> 
        </div> 
        <div class="paragraph"> 
         <p>However, there are plenty of cases where the included file might intend to refer to the application’s root config. For example, to get a value from a system property or from the reference configuration. So it’s not enough to only look up the "fixed up" path, it’s necessary to look up the original path as well.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="include-semantics-missing-files"><a class="anchor" href="#include-semantics-missing-files"></a>Include semantics: missing files</h4> 
        <div class="paragraph"> 
         <p>If an included file does not exist, the include statement should be silently ignored (as if the included file contained only an empty object).</p> 
        </div> 
        <div class="paragraph"> 
         <p>Other IO errors probably should not be ignored but implementations will have to make a judgment which IO errors reflect an ignorable missing file, and which reflect a problem to bring to the user’s attention.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="include-semantics-file-formats-and-extensions"><a class="anchor" href="#include-semantics-file-formats-and-extensions"></a>Include semantics: file formats and extensions</h4> 
        <div class="paragraph"> 
         <p>Implementations may support including files in other formats. Those formats must be compatible with the JSON type system, or have some documented mapping to JSON’s type system.</p> 
        </div> 
        <div class="paragraph"> 
         <p>If an implementation supports multiple formats, then the extension may be omitted from the name of included files:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>include "foo"</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>If a filename has no extension, the implementation should treat it as a basename and try loading the file with all known extensions.</p> 
        </div> 
        <div class="paragraph"> 
         <p>If the file exists with multiple extensions, they should <em>all</em> be loaded and merged together.</p> 
        </div> 
        <div class="paragraph"> 
         <p>Files in HOCON format should be parsed last. Files in JSON format should be parsed next-to-last.</p> 
        </div> 
        <div class="paragraph"> 
         <p>In short, <code>include "foo"</code> might be equivalent to:</p> 
        </div> 
        <div class="listingblock"> 
         <div class="content"> 
          <pre>include "foo.properties"
include "foo.json"
include "foo.conf"</pre> 
         </div> 
        </div> 
        <div class="paragraph"> 
         <p>This same extension-based behavior is applied to classpath resources and files.</p> 
        </div> 
        <div class="paragraph"> 
         <p>For URLs, a basename without extension is not allowed; only the exact URL specified is used. The format will be chosen based on the Content-Type if available, or by the extension of the path component of the URL if no Content-Type is set. This is true even for file: URLs.</p> 
        </div> 
       </div> 
       <div class="sect3"> 
        <h4 id="include-semantics-locating-resources"><a class="anchor" href="#include-semantics-locating-resources"></a>Include semantics: locating resources</h4> 
        <div class="paragraph"> 
         <p>A quoted string not surrounded by <code>url()</code>, <code>file()</code>, <code>classpath()</code> must be interpreted heuristically. The heuristic is to treat the quoted string as:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>a URL, if the quoted string is a valid URL with a known protocol.</p> </li> 
          <li> <p>otherwise, a file or other resource "adjacent to" the one being parsed and of the same type as the one being parsed. The meaning of "adjacent to", and the string itself, has to be specified separately for each kind of resource.</p> </li> 
          <li> <p>On the Java Virtual Machine, if an include statement does not identify a valid URL or an existing resource "adjacent to" the including resource, implementations may wish to fall back to a classpath resource. This allows configurations found in files or URLs to access classpath resources in a natural way.</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>Implementations may vary in the kinds of resources they can include.</p> 
        </div> 
        <div class="paragraph"> 
         <p>For resources located on the Java classpath:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>included resources are looked up by calling <code>getResource()</code> on the same class loader used to look up the including resource.</p> </li> 
          <li> <p>if the included resource name is absolute (starts with <em>/</em>) then it should be passed to <code>getResource()</code> with the <em>/</em> removed.</p> </li> 
          <li> <p>if the included resource name does not start with <em>/</em> then it should have the "directory" of the including resource prepended to it, before passing it to <code>getResource()</code>. If the including resource is not absolute (no <em>/</em>) and has no "parent directory" (is just a single path element), then the included relative resource name should be left as-is.</p> </li> 
          <li> <p>it would be wrong to use <code>getResource()</code> to get a URL and then locate the included name relative to that URL, because a class loader is not required to have a one-to-one mapping between paths in its URLs and the paths it handles in <code>getResource()</code>. In other words, the "adjacent to" computation should be done on the resource name not on the resource’s URL.</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>For plain files on the filesystem:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>if the included file is an absolute path then it should be kept absolute and loaded as such.</p> </li> 
          <li> <p>if the included file is a relative path, then it should be located relative to the directory containing the including file. The current working directory of the process parsing a file must NOT be used when interpreting included paths.</p> </li> 
          <li> <p>if the file is not found, fall back to the classpath resource. The classpath resource should not have any package name added in front, it should be relative to the "root"; which means any leading "/" should just be removed (absolute is the same as relative since it’s root-relative). The "/" is handled for consistency with including resources from inside other classpath resources, where the resource name may not be root-relative and "/" allows specifying relative to root.</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>URLs:</p> 
        </div> 
        <div class="ulist"> 
         <ul> 
          <li> <p>for files loaded from a URL, "adjacent to" should be based on parsing the URL’s path component, replacing the last path element with the included name.</p> </li> 
          <li> <p>file: URLs should behave in exactly the same way as a plain filename</p> </li> 
         </ul> 
        </div> 
        <div class="paragraph"> 
         <p>Implementations need not support files, Java resources, or URLs; and they need not support particular URL protocols. However, if they do support them they should do so as described above.</p> 
        </div> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="conversion-of-numerically-indexed-objects-to-arrays"><a class="anchor" href="#conversion-of-numerically-indexed-objects-to-arrays"></a>Conversion of numerically-indexed objects to arrays</h3> 
       <div class="paragraph"> 
        <p>In some file formats and contexts, such as Java properties files, there isn’t a good way to define arrays. To provide some mechanism for this, implementations should support converting objects with numeric keys into arrays. For example, this object:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>{ "0" : "a", "1" : "b" }</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>could be treated as:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>[ "a", "b" ]</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>This allows creating an array in a properties file like this:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>foo.0 = "a"
foo.1 = "b"</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>The details:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>the conversion should be done lazily when required to avoid a type error, NOT eagerly anytime an object has numeric keys.</p> </li> 
         <li> <p>the conversion should be done when you would do an automatic type conversion (see the section "Automatic type conversions" below).</p> </li> 
         <li> <p>the conversion should be done in a concatenation when a list is expected and an object with numeric keys is found.</p> </li> 
         <li> <p>the conversion should not occur if the object is empty or has no keys which parse as positive integers.</p> </li> 
         <li> <p>the conversion should ignore any keys which do not parse as positive integers.</p> </li> 
         <li> <p>the conversion should sort by the integer value of each key and then build the array; if the integer keys are "0" and "2" then the resulting array would have indices "0" and "1", i.e. missing indices in the object are eliminated.</p> </li> 
        </ul> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="sect1"> 
     <h2 id="mime-type"><a class="anchor" href="#mime-type"></a>MIME Type</h2> 
     <div class="sectionbody"> 
      <div class="paragraph"> 
       <p>Use "application/hocon" for Content-Type.</p> 
      </div> 
     </div> 
    </div> 
    <div class="sect1"> 
     <h2 id="api-recommendations"><a class="anchor" href="#api-recommendations"></a>API Recommendations</h2> 
     <div class="sectionbody"> 
      <div class="paragraph"> 
       <p>Implementations of HOCON ideally follow certain conventions and work in a predictable way.</p> 
      </div> 
      <div class="sect2"> 
       <h3 id="automatic-type-conversions"><a class="anchor" href="#automatic-type-conversions"></a>Automatic type conversions</h3> 
       <div class="paragraph"> 
        <p>If an application asks for a value with a particular type, the implementation should attempt to convert types as follows:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>number to string: convert the number into a string representation that would be a valid number in JSON.</p> </li> 
         <li> <p>boolean to string: should become the string "true" or "false"</p> </li> 
         <li> <p>string to number: parse the number with the JSON rules</p> </li> 
         <li> <p>string to boolean: the strings "true", "yes", "on", "false", "no", "off" should be converted to boolean values. It’s tempting to support a long list of other ways to write a boolean, but for interoperability and keeping it simple, it’s recommended to stick to these six.</p> </li> 
         <li> <p>string to null: the string <code>"null"</code> should be converted to a null value if the application specifically asks for a null value, though there’s probably no reason an app would do this.</p> </li> 
         <li> <p>numerically-indexed object to array: see the section "Conversion of numerically-indexed objects to arrays" above</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>The following type conversions should NOT be performed:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>null to anything: If the application asks for a specific type and finds null instead, that should usually result in an error.</p> </li> 
         <li> <p>object to anything</p> </li> 
         <li> <p>array to anything</p> </li> 
         <li> <p>anything to object</p> </li> 
         <li> <p>anything to array, with the exception of numerically-indexed object to array</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Converting objects and arrays to and from strings is tempting, but in practical situations raises thorny issues of quoting and double-escaping.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="units-format"><a class="anchor" href="#units-format"></a>Units format</h3> 
       <div class="paragraph"> 
        <p>Implementations may wish to support interpreting a value with some family of units, such as time units or memory size units: <code>10ms</code> or <code>512K</code>. HOCON does not have an extensible type system and there is no way to add a "duration" type. However, for example, if an application asks for milliseconds, the implementation can try to interpret a value as a milliseconds value.</p> 
       </div> 
       <div class="paragraph"> 
        <p>If an API supports this, for each family of units it should define a default unit in the family. For example, the family of duration units might default to milliseconds (see below for details on durations). The implementation should then interpret values as follows:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>if the value is a number, it is taken to be a number in the default unit.</p> </li> 
         <li> <p>if the value is a string, it is taken to be this sequence:</p> 
          <div class="ulist"> 
           <ul> 
            <li> <p>optional whitespace</p> </li> 
            <li> <p>a number</p> </li> 
            <li> <p>optional whitespace</p> </li> 
            <li> <p>an optional unit name consisting only of letters (letters are the Unicode <code>L*</code> categories, Java <code>isLetter()</code>)</p> </li> 
            <li> <p>optional whitespace</p> </li> 
           </ul> 
          </div> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>If a string value has no unit name, then it should be interpreted with the default unit, as if it were a number. If a string value has a unit name, that name of course specifies the value’s interpretation.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="duration-format"><a class="anchor" href="#duration-format"></a>Duration format</h3> 
       <div class="paragraph"> 
        <p>Implementations may wish to support a <code>getMilliseconds()</code> (and similar for other time units).</p> 
       </div> 
       <div class="paragraph"> 
        <p>This can use the general "units format" described above; bare numbers are taken to be in milliseconds already, while strings are parsed as a number plus an optional unit string.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The supported unit strings for duration are case sensitive and must be lowercase. Exactly these strings are supported:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>ns</code>, <code>nanosecond</code>, <code>nanoseconds</code></p> </li> 
         <li> <p><code>us</code>, <code>microsecond</code>, <code>microseconds</code></p> </li> 
         <li> <p><code>ms</code>, <code>millisecond</code>, <code>milliseconds</code></p> </li> 
         <li> <p><code>s</code>, <code>second</code>, <code>seconds</code></p> </li> 
         <li> <p><code>m</code>, <code>minute</code>, <code>minutes</code></p> </li> 
         <li> <p><code>h</code>, <code>hour</code>, <code>hours</code></p> </li> 
         <li> <p><code>d</code>, <code>day</code>, <code>days</code></p> </li> 
        </ul> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="size-in-bytes-format"><a class="anchor" href="#size-in-bytes-format"></a>Size in bytes format</h3> 
       <div class="paragraph"> 
        <p>Implementations may wish to support a <code>getBytes()</code> returning a size in bytes.</p> 
       </div> 
       <div class="paragraph"> 
        <p>This can use the general "units format" described above; bare numbers are taken to be in bytes already, while strings are parsed as a number plus an optional unit string.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The one-letter unit strings may be uppercase (note: duration units are always lowercase, so this convention is specific to size units).</p> 
       </div> 
       <div class="paragraph"> 
        <p>There is an unfortunate nightmare with size-in-bytes units, that they may be in powers or two or powers of ten. The approach defined by standards bodies appears to differ from common usage, such that following the standard leads to people being confused. Worse, common usage varies based on whether people are talking about RAM or disk sizes, and various existing operating systems and apps do all kinds of different things. See <a href="http://en.wikipedia.org/wiki/Binary_prefix#Deviation_between_powers_of_1024_and_powers_of_1000">http://en.wikipedia.org/wiki/Binary_prefix#Deviation_between_powers_of_1024_and_powers_of_1000</a> for examples. It appears impossible to sort this out without causing confusion for someone sometime.</p> 
       </div> 
       <div class="paragraph"> 
        <p>For single bytes, exactly these strings are supported:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>B</code>, <code>b</code>, <code>byte</code>, <code>bytes</code></p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>For powers of ten, exactly these strings are supported:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>kB</code>, <code>kilobyte</code>, <code>kilobytes</code></p> </li> 
         <li> <p><code>MB</code>, <code>megabyte</code>, <code>megabytes</code></p> </li> 
         <li> <p><code>GB</code>, <code>gigabyte</code>, <code>gigabytes</code></p> </li> 
         <li> <p><code>TB</code>, <code>terabyte</code>, <code>terabytes</code></p> </li> 
         <li> <p><code>PB</code>, <code>petabyte</code>, <code>petabytes</code></p> </li> 
         <li> <p><code>EB</code>, <code>exabyte</code>, <code>exabytes</code></p> </li> 
         <li> <p><code>ZB</code>, <code>zettabyte</code>, <code>zettabytes</code></p> </li> 
         <li> <p><code>YB</code>, <code>yottabyte</code>, <code>yottabytes</code></p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>For powers of two, exactly these strings are supported:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>K</code>, <code>k</code>, <code>Ki</code>, <code>KiB</code>, <code>kibibyte</code>, <code>kibibytes</code></p> </li> 
         <li> <p><code>M</code>, <code>m</code>, <code>Mi</code>, <code>MiB</code>, <code>mebibyte</code>, <code>mebibytes</code></p> </li> 
         <li> <p><code>G</code>, <code>g</code>, <code>Gi</code>, <code>GiB</code>, <code>gibibyte</code>, <code>gibibytes</code></p> </li> 
         <li> <p><code>T</code>, <code>t</code>, <code>Ti</code>, <code>TiB</code>, <code>tebibyte</code>, <code>tebibytes</code></p> </li> 
         <li> <p><code>P</code>, <code>p</code>, <code>Pi</code>, <code>PiB</code>, <code>pebibyte</code>, <code>pebibytes</code></p> </li> 
         <li> <p><code>E</code>, <code>e</code>, <code>Ei</code>, <code>EiB</code>, <code>exbibyte</code>, <code>exbibytes</code></p> </li> 
         <li> <p><code>Z</code>, <code>z</code>, <code>Zi</code>, <code>ZiB</code>, <code>zebibyte</code>, <code>zebibytes</code></p> </li> 
         <li> <p><code>Y</code>, <code>y</code>, <code>Yi</code>, <code>YiB</code>, <code>yobibyte</code>, <code>yobibytes</code></p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>It’s very unclear which units the single-character abbreviations ("128K") should go with; some precedents such as <code>java -Xmx 2G</code> and the GNU tools such as <code>ls</code> map these to powers of two, so this spec copies that. You can certainly find examples of mapping these to powers of ten, though. If you don’t like ambiguity, don’t use the single-letter abbreviations.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="config-object-merging-and-file-merging"><a class="anchor" href="#config-object-merging-and-file-merging"></a>Config object merging and file merging</h3> 
       <div class="paragraph"> 
        <p>It may be useful to offer a method to merge two objects. If such a method is provided, it should work as if the two objects were duplicate values for the same key in the same file. (See the section earlier on duplicate key handling.)</p> 
       </div> 
       <div class="paragraph"> 
        <p>As with duplicate keys, an intermediate non-object value "hides" earlier object values. So say you merge three objects in this order:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>{ a : { x : 1 } }</code> (first priority)</p> </li> 
         <li> <p><code>{ a : 42 }</code> (fallback)</p> </li> 
         <li> <p><code>{ a : { y : 2 } }</code> (another fallback)</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>The result would be <code>{ a : { x : 1 } }</code>. The two objects are not merged because they are not "adjacent"; the merging is done in pairs, and when <code>42</code> is paired with <code>{ y : 2 }</code>, <code>42</code> simply wins and loses all information about what it overrode.</p> 
       </div> 
       <div class="paragraph"> 
        <p>But if you re-ordered like this:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p><code>{ a : { x : 1 } }</code> (first priority)</p> </li> 
         <li> <p><code>{ a : { y : 2 } }</code> (fallback)</p> </li> 
         <li> <p><code>{ a : 42 }</code> (another fallback)</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>Now the result would be <code>{ a : { x : 1, y : 2 } }</code> because the two objects are adjacent.</p> 
       </div> 
       <div class="paragraph"> 
        <p>This rule for merging objects loaded from different files is <em>exactly</em> the same behavior as for merging duplicate fields in the same file. All merging works the same way.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Needless to say, normally it’s well-defined whether a config setting is supposed to be a number or an object. This kind of weird pathology where the two are mixed should not be happening.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The one place where it matters, though, is that it allows you to "clear" an object and start over by setting it to null and then setting it back to a new object. So this behavior gives people a way to get rid of default fallback values they don’t want.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="java-properties-mapping"><a class="anchor" href="#java-properties-mapping"></a>Java properties mapping</h3> 
       <div class="paragraph"> 
        <p>It may be useful to merge Java properties data with data loaded from JSON or HOCON. See the Java properties spec here: <a href="http://download.oracle.com/javase/7/docs/api/java/util/Properties.html#load%28java.io.Reader%29">http://download.oracle.com/javase/7/docs/api/java/util/Properties.html#load%28java.io.Reader%29</a></p> 
       </div> 
       <div class="paragraph"> 
        <p>Java properties parse as a one-level map from string keys to string values.</p> 
       </div> 
       <div class="paragraph"> 
        <p>To convert to HOCON, first split each key on the <code>.</code> character, keeping any empty strings (including leading and trailing empty strings). Note that this is <em>very different</em> from parsing a path expression.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The key split on <code>.</code> is a series of path elements. So the properties key with just <code>.</code> is a path with two elements, both of them an empty string. <code>a.</code> is a path with two elements, <code>a</code> and empty string. (Java’s <code>String.split()</code> does NOT do what you want for this.)</p> 
       </div> 
       <div class="paragraph"> 
        <p>It is impossible to represent a key with a <code>.</code> in it in a properties file. If a JSON/HOCON key has a <code>.</code> in it, which is possible if the key is quoted, then there is no way to refer to it as a Java property. It is not recommended to name HOCON keys with a <code>.</code> in them, since it would be confusing at best in any case.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Once you have a path for each value, construct a tree of JSON-style objects with the string value of each property located at that value’s path.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Values from properties files are <em>always</em> strings, even if they could be parsed as some other type. Implementations should do type conversion if an app asks for an integer, as described in an earlier section.</p> 
       </div> 
       <div class="paragraph"> 
        <p>When Java loads a properties file, unfortunately it does not preserve the order of the file. As a result, there is an intractable case where a single key needs to refer to both a parent object and a string value. For example, say the Java properties file has:</p> 
       </div> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre>a=hello
a.b=world</pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>In this case, <code>a</code> needs to be both an object and a string value. The <em>object</em> must always win in this case… the "object wins" rule throws out at most one value (the string) while "string wins" would throw out all values in the object. Unfortunately, when properties files are mapped to the JSON structure, there is no way to access these strings that conflict with objects.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The usual rule in HOCON would be that the later assignment in the file wins, rather than "object wins"; but implementing that for Java properties would require implementing a custom Java properties parser, which is surely not worth it and wouldn’t help with system properties anyway.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="conventional-configuration-files-for-jvm-apps"><a class="anchor" href="#conventional-configuration-files-for-jvm-apps"></a>Conventional configuration files for JVM apps</h3> 
       <div class="paragraph"> 
        <p>By convention, JVM apps have two parts to their configuration:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>the <em>reference</em> config is made up of all resources named <code>reference.conf</code> on the classpath, merged in the order they are returned by <code>ClassLoader.getResources()</code>; also, system property overrides are applied.</p> </li> 
         <li> <p>the <em>application</em> config can be loaded from anywhere an application likes, but by default if the application doesn’t provide a config it would be loaded from files <code>application.{conf,json,properties}</code> on the classpath and then system property overrides are applied.</p> </li> 
         <li> <p>the reference config may be different for different class loaders, since each jar may provide a <code>reference.conf</code> to go with the code in that jar.</p> </li> 
         <li> <p>a single JVM may have multiple application configs if it has multiple modules or contexts of some kind.</p> </li> 
        </ul> 
       </div> 
       <div class="paragraph"> 
        <p>The reference config for a given class loader should be merged and resolved first, and may be shared among all application configs in that class loader. Substitutions in the reference config are not affected by any application configs, because the reference config should be resolved by itself.</p> 
       </div> 
       <div class="paragraph"> 
        <p>The application config should then be loaded, have the reference config added as a fallback, and have substitutions resolved. This means the application config can refer to the reference config in its substitutions.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="conventional-override-by-system-properties"><a class="anchor" href="#conventional-override-by-system-properties"></a>Conventional override by system properties</h3> 
       <div class="paragraph"> 
        <p>For an application’s config, Java system properties <em>override</em> settings found in the configuration file. This supports specifying config options on the command line.</p> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="substitution-fallback-to-environment-variables"><a class="anchor" href="#substitution-fallback-to-environment-variables"></a>Substitution fallback to environment variables</h3> 
       <div class="paragraph"> 
        <p>Recall that if a substitution is not present (not even set to <code>null</code>) within a configuration tree, implementations may search for it from external sources. One such source could be environment variables.</p> 
       </div> 
       <div class="paragraph"> 
        <p>It’s recommended that HOCON keys always use lowercase, because environment variables generally are capitalized. This avoids naming collisions between environment variables and configuration properties. (While on Windows getenv() is generally not case-sensitive, the lookup will be case sensitive all the way until the env variable fallback lookup is reached.)</p> 
       </div> 
       <div class="paragraph"> 
        <p>An application can explicitly block looking up a substitution in the environment by setting a value in the configuration, with the same name as the environment variable. You could set <code>HOME : null</code> in your root object to avoid expanding <code>${HOME}</code> from the environment, for example.</p> 
       </div> 
       <div class="paragraph"> 
        <p>Environment variables are interpreted as follows:</p> 
       </div> 
       <div class="ulist"> 
        <ul> 
         <li> <p>env variables set to the empty string are kept as such (set to empty string, rather than undefined)</p> </li> 
         <li> <p>System.getenv throws SecurityException: treated as not present</p> </li> 
         <li> <p>encoding is handled by Java (System.getenv already returns a Unicode string)</p> </li> 
         <li> <p>environment variables always become a string value, though if an app asks for another type automatic type conversion would kick in</p> </li> 
        </ul> 
       </div> 
      </div> 
      <div class="sect2"> 
       <h3 id="hyphen-separated-vs.-camelcase"><a class="anchor" href="#hyphen-separated-vs.-camelcase"></a>hyphen-separated vs. camelCase</h3> 
       <div class="paragraph"> 
        <p>Config keys are encouraged to be <code>hyphen-separated</code> rather than <code>camelCase</code>.</p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="sect1"> 
     <h2 id="note-on-java-properties-similarity"><a class="anchor" href="#note-on-java-properties-similarity"></a>Note on Java properties similarity</h2> 
     <div class="sectionbody"> 
      <div class="paragraph"> 
       <p>You can write a HOCON file that looks much like a Java properties file, and many valid Java properties files will also parse as HOCON.</p> 
      </div> 
      <div class="paragraph"> 
       <p>However, HOCON is not a Java properties superset and the corner cases work like JSON, not like properties.</p> 
      </div> 
      <div class="paragraph"> 
       <p>Differences include but are probably not limited to:</p> 
      </div> 
      <div class="ulist"> 
       <ul> 
        <li> <p>certain characters that can be unquoted in properties files have to be placed in JSON-style double-quoted strings in HOCON</p> </li> 
        <li> <p>unquoted strings in HOCON do not support escape sequences</p> </li> 
        <li> <p>unquoted strings in HOCON do not preserve trailing whitespace</p> </li> 
        <li> <p>multi-line unquoted strings using backslash to continue the line are not allowed in HOCON</p> </li> 
        <li> <p>in properties files you can omit the value for a key and it’s interpreted as an empty string, in HOCON you cannot omit the value</p> </li> 
        <li> <p>properties files support <em>!</em> as a comment character</p> </li> 
        <li> <p>HOCON allows comments on the same line as a key or value, while properties files only recognize comment characters if they occur as the first character on the line</p> </li> 
        <li> <p>HOCON interprets <code>${}</code> as a substitution</p> </li> 
       </ul> 
      </div> 
     </div> 
    </div> 
    <p></p> 
   </div> 
   <div id="push"></div> 
  </div> 
  <div id="footer"> 
   <p class="muted credit">© 2015 | Werval 0.7.2 | The Werval Community</p> 
   <p class="muted credit"> Authored with <a href="http://asciidoctor.org/">Asciidoctor</a> | Baked with <a href="http://jbake.org">JBake</a> | Mixed with <a href="http://getbootstrap.com/">Bootstrap</a> </p> 
  </div> 
  <!-- Le javascript
    ================================================== --> 
  <!-- Placed at the end of the document so the pages load faster --> 
  <script src="js/jquery-1.11.1.min.js"></script> 
  <script src="js/bootstrap.min.js"></script> 
  <script src="js/prettify.js"></script> 
  <script src="js/io.werval.doc.js"></script>  
 </body>
</html>